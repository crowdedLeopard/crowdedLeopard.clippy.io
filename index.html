<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Signals Run</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Basic Reset & Font */
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden; /* Prevent body scroll */
        }

        /* Game Container */
        #game-container {
            width: 800px;
            height: 500px;
            border: 3px solid #3b82f6; /* Blue border */
            position: relative;
            overflow: hidden; /* Crucial for side-scrolling */
            background-color: #a2d9ff; /* Fallback sky blue */
        }

        /* Static Background */
        #background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* Static width */
            height: 100%;
            background-image: url('https://wallpaperaccess.com/full/3480667.jpg');
            background-repeat: no-repeat; /* No repeat for static */
            background-size: cover; /* Cover the container */
            background-position: center center; /* Center the image */
            z-index: 0;
        }

        /* Clippy Character */
        #clippy {
            position: absolute;
            bottom: 50px; /* Initial ground position */
            left: 100px; /* Fixed horizontal position */
            width: 35px; /* Adjusted size */
            height: 55px; /* Adjusted height */
            z-index: 10;
        }

        /* Obstacles (Microsoft Logo placeholders) */
        .obstacle {
            position: absolute;
            bottom: 50px; /* Align with ground */
            width: 60px; /* Width based on 2x2 grid */
            /* Height set dynamically */
            z-index: 5;
            display: grid; /* Use grid for the 4 squares */
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            border: 1px solid #555; /* Optional border for the container */
        }
        .obstacle-tile { }
        .obstacle-tile-red { background-color: #F25022; }
        .obstacle-tile-green { background-color: #7FBA00; }
        .obstacle-tile-blue { background-color: #00A4EF; }
        .obstacle-tile-yellow { background-color: #FFB900; }


        /* Letters to Collect */
        .letter {
            position: absolute;
            width: 30px;
            height: 30px;
            font-size: 24px;
            font-weight: bold;
            color: #ffeb3b; /* Brighter Yellow */
            text-align: center;
            line-height: 30px;
            z-index: 6;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
        }

        /* UI Display */
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 20;
            background-color: rgba(255, 255, 255, 0.85);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            color: #1e3a8a; /* Dark blue text */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Start/Game Over Overlay */
        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.65);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 30;
            font-size: 28px;
            cursor: pointer;
            backdrop-filter: blur(3px); /* Optional blur effect */
        }
        #message-overlay h2 {
            margin-bottom: 15px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }
         #message-overlay p {
            font-size: 20px;
            margin-top: 5px;
            margin-bottom: 10px;
         }

        /* Styling for the embedded Clippy SVG */
        .clippy-svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.4)); /* Add subtle shadow */
        }
        /* Reverted Clippy Body Style (Stroke, No Fill) */
        .clippy-body {
            fill: none; /* No fill */
            stroke: #9ca3af; /* Gray stroke */
            stroke-width: 5; /* Stroke width */
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        .clippy-eyes { fill: #ffffff; stroke: #4b5563; stroke-width: 1;}
        .clippy-pupils { fill: #1f2937; }
        .clippy-brows { fill: none; stroke: #1f2937; stroke-width: 2; stroke-linecap: round;}


    </style>
</head>
<body>
    <div id="game-container">
        <div id="background"></div>
        <div id="clippy">
             <svg class="clippy-svg" viewBox="0 0 40 60">
                 <g>
                    <path class="clippy-body" d="M20 5 C 10 5 5 10 5 20 C 5 30 10 35 20 35 C 30 35 35 30 35 20 C 35 10 30 5 20 5 M 12 20 C 12 15 28 15 28 20 L 28 50 C 28 55 12 55 12 50 Z" />
                    <circle class="clippy-eyes" cx="15" cy="23" r="4"/>
                    <circle class="clippy-eyes" cx="25" cy="23" r="4"/>
                    <circle class="clippy-pupils" cx="15.5" cy="24" r="2"/>
                    <circle class="clippy-pupils" cx="25.5" cy="24" r="2"/>
                     <path class="clippy-brows" d="M12 18 Q 15 15 18 18" />
                     <path class="clippy-brows" d="M22 18 Q 25 15 28 18" />
                </g>
            </svg>
        </div>
        <div id="ui">Collect: <span id="next-letter-display">T</span> | Got: <span id="collected-letters"></span></div>
        <div id="message-overlay">
            <h2>Signals Run</h2>
            <p>Press Spacebar to Jump!</p>
            <p>Land on logos, avoid sides, collect T-H-R-I-V-I-N-G in order.</p>
            <p>Click or press Spacebar to Start</p>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const gameContainer = document.getElementById('game-container');
        const background = document.getElementById('background');
        const clippy = document.getElementById('clippy');
        const uiCollected = document.getElementById('collected-letters');
        const uiNextLetter = document.getElementById('next-letter-display');
        const messageOverlay = document.getElementById('message-overlay');

        // --- Game Constants ---
        const GRAVITY = 0.6;
        const JUMP_FORCE = -12;
        const GROUND_Y = 50;
        const GAME_WIDTH = gameContainer.offsetWidth;
        const GAME_HEIGHT = gameContainer.offsetHeight;
        const SCROLL_SPEED = 3.5;
        // --- Obstacle Spawning Timing ---
        const MIN_OBSTACLE_INTERVAL = 90; // Minimum frames between obstacles
        const MAX_OBSTACLE_INTERVAL = 200; // Maximum frames between obstacles
        // --- Letter Spawning Timing ---
        const LETTER_SPAWN_INTERVAL = 100; // Attempt spawn check every X frames
        const TARGET_WORD = "THRIVING";
        const CLIPPY_WIDTH = 30;
        const CLIPPY_HEIGHT = 50;
        const CLIPPY_X_POS = 100;
        const LETTER_MIN_Y = 70;
        const LETTER_MAX_Y = 220;
        const MIN_SPAWN_GAP = 180; // Min horizontal pixels between any spawned items

        // --- Game State Variables ---
        let clippyY = GROUND_Y;
        let clippyVY = 0;
        let onPlatform = false;
        let obstacles = [];
        let letters = [];
        let frameCount = 0;
        let collectedString = "";
        let nextLetterIndex = 0;
        let nextObstacleSpawnFrame = 0; // Frame number when the next obstacle should spawn
        let gameActive = false;
        let animationFrameId = null;
        let audioStarted = false;

        // --- Sound Setup (Tone.js) ---
        let synth;
        try {
            synth = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: {
                    attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2
                }
            }).toDestination();
        } catch (e) { console.error("Tone.js synth could not be created:", e); synth = null; }


        // --- Game Functions ---

        async function startAudio() {
            if (!audioStarted && Tone.context.state !== 'running') {
                try {
                    await Tone.start();
                    console.log("Audio context started!");
                    audioStarted = true;
                } catch (e) { console.error("Tone.start() failed:", e); }
            }
        }

        function playPlopSound() {
            if (synth && audioStarted) {
                try { synth.triggerAttackRelease("G3", "16n", Tone.now()); }
                catch (e) { console.error("Error playing sound:", e); }
            }
        }

        /**
         * Calculates the frame number for the next obstacle spawn using a random interval.
         */
        function setNextObstacleSpawnTime() {
            const interval = Math.floor(Math.random() * (MAX_OBSTACLE_INTERVAL - MIN_OBSTACLE_INTERVAL + 1)) + MIN_OBSTACLE_INTERVAL;
            nextObstacleSpawnFrame = frameCount + interval;
            // console.log(`Next obstacle spawn scheduled for frame: ${nextObstacleSpawnFrame} (in ${interval} frames)`);
        }


        function resetGame() {
            console.log("Resetting game...");
            clippyY = GROUND_Y;
            clippyVY = 0;
            clippy.style.bottom = `${clippyY}px`;
            onPlatform = true;

            obstacles.forEach(obs => obs.element.remove());
            obstacles = [];
            letters.forEach(let => let.element.remove());
            letters = [];

            frameCount = 0;
            collectedString = "";
            nextLetterIndex = 0;
            setNextObstacleSpawnTime(); // Set initial obstacle spawn time
            uiCollected.textContent = "";
            uiNextLetter.textContent = TARGET_WORD[0];
            gameActive = true;
            messageOverlay.style.display = 'none';

            if (!animationFrameId) {
                console.log("Starting game loop from reset.");
                gameLoop();
            }
        }

        async function startGame() {
            await startAudio();
            if (!gameActive) {
                 resetGame();
            }
        }

        function gameOver(reason = "hit an obstacle") {
            if (!gameActive) return;
            console.log("Game Over!", reason);
            gameActive = false;
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;

            messageOverlay.innerHTML = `
                <h2>Game Over!</h2>
                <p>(${reason})</p>
                <p>You collected: ${collectedString}</p>
                <p>Click or press Spacebar to Play Again</p>
            `;
            messageOverlay.style.display = 'flex';
        }

        /**
         * Applies gravity and handles landing/snapping to ground or platforms.
         * More robust landing check using previous position.
         */
        function applyGravityAndPlatformCheck() {
            if (!gameActive) return;

            const prevClippyY = clippyY; // Store position before applying velocity
            let landedOnPlatform = false;
            let platformTopY = GROUND_Y; // Default to ground

            // Apply gravity
            clippyVY += GRAVITY;
            clippyY -= clippyVY;

            // Check for platform landing ONLY if moving downwards (or stationary)
            if (clippyVY >= 0) {
                for (const obs of obstacles) {
                    const obsTopSurfaceY = obs.y + obs.height;
                    const isHorizontallyAligned =
                        CLIPPY_X_POS < obs.x + obs.width - 5 &&
                        CLIPPY_X_POS + CLIPPY_WIDTH > obs.x + 5;

                    // Check if Clippy crossed the platform's top surface this frame
                    if (isHorizontallyAligned && prevClippyY >= obsTopSurfaceY && clippyY <= obsTopSurfaceY) {
                        landedOnPlatform = true;
                        platformTopY = obsTopSurfaceY; // Land on this platform
                        break; // Landed, no need to check others
                    }
                }
            }

            // Handle landing or ground collision
            if (landedOnPlatform) {
                clippyY = platformTopY; // Snap to platform top
                clippyVY = 0;
                onPlatform = true;
            } else {
                // Check ground collision if not landing on a platform
                if (clippyY <= GROUND_Y) {
                    clippyY = GROUND_Y; // Snap to ground
                    clippyVY = 0;
                    onPlatform = true; // On the ground platform
                } else {
                    onPlatform = false; // In the air
                }
            }

             // Ceiling check
             if (clippyY >= GAME_HEIGHT - CLIPPY_HEIGHT) {
                 clippyY = GAME_HEIGHT - CLIPPY_HEIGHT;
                 clippyVY = 0;
             }

            clippy.style.bottom = `${clippyY}px`;
        }


        function jump() {
            if (onPlatform && gameActive) {
                clippyVY = JUMP_FORCE;
                onPlatform = false;
            }
        }

        function spawnObstacle() {
            if (!gameActive) return;
            const minHeight = 30;
            const maxHeight = 90;
            const tileHeight = 30;
            const numTilesHigh = Math.floor(Math.random() * (maxHeight / tileHeight - minHeight / tileHeight + 1) + minHeight / tileHeight);
            const height = numTilesHigh * tileHeight;

            const obstacleElement = document.createElement('div');
            obstacleElement.classList.add('obstacle');
            obstacleElement.style.height = `${height}px`;
            obstacleElement.style.left = `${GAME_WIDTH}px`;
            obstacleElement.style.gridTemplateRows = `repeat(${numTilesHigh}, 1fr)`;

             const colors = ['red', 'green', 'blue', 'yellow'];
             for(let r = 0; r < numTilesHigh; r++) {
                 for (let c = 0; c < 2; c++) {
                     const tile = document.createElement('div');
                     tile.classList.add('obstacle-tile');
                     const colorIndex = (r * 2 + c) % 4;
                     tile.classList.add(`obstacle-tile-${colors[colorIndex]}`);
                     obstacleElement.appendChild(tile);
                 }
             }

            gameContainer.appendChild(obstacleElement);
            obstacles.push({
                element: obstacleElement,
                x: GAME_WIDTH,
                y: GROUND_Y,
                width: 60,
                height: height
            });

            // --- Set time for the NEXT obstacle spawn ---
            setNextObstacleSpawnTime();
        }

        function spawnLetter() {
            if (!gameActive || nextLetterIndex >= TARGET_WORD.length) return;

            const letterChar = TARGET_WORD[nextLetterIndex];
            const letterElement = document.createElement('div');
            letterElement.classList.add('letter');
            letterElement.textContent = letterChar;

            const letterY = Math.random() * (LETTER_MAX_Y - LETTER_MIN_Y) + LETTER_MIN_Y;
            letterElement.style.bottom = `${letterY}px`;
            letterElement.style.left = `${GAME_WIDTH}px`;

            gameContainer.appendChild(letterElement);
            const newLetter = {
                element: letterElement,
                x: GAME_WIDTH,
                y: letterY,
                width: 30,
                height: 30,
                char: letterChar
            };
            letters.push(newLetter);
        }


        /**
         * Updates element positions, checks side collisions, handles letter collection.
         */
        function updateElements() {
            if (!gameActive) return;

            // --- Update Obstacles ---
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.x -= SCROLL_SPEED;
                obs.element.style.left = `${obs.x}px`;

                // --- Refined Side Collision Check ---
                // Only check if Clippy is roughly vertically aligned and horizontally overlapping
                const obsTopY = obs.y + obs.height;
                const isHorizontallyAligned =
                        CLIPPY_X_POS + CLIPPY_WIDTH > obs.x + 5 && // Clippy right edge past obstacle left edge (+ buffer)
                        CLIPPY_X_POS < obs.x + obs.width - 5;   // Clippy left edge before obstacle right edge (- buffer)

                if (isHorizontallyAligned) {
                    const clippyBottom = clippyY;
                    const clippyTop = clippyY + CLIPPY_HEIGHT;

                    // Check for vertical overlap (Clippy top above obs bottom AND Clippy bottom below obs top)
                    // Added buffer (e.g., 5px) to avoid triggering on exact pixel alignment with top/bottom, giving landing priority
                    if (clippyTop > obs.y + 5 && clippyBottom < obsTopY - 5) {
                         // This indicates a definite side collision, not a landing/grazing touch
                         gameOver(`hit the side of an obstacle`);
                         return;
                    }
                }

                // Remove if off-screen left
                if (obs.x + obs.width < 0) {
                    obs.element.remove();
                    obstacles.splice(i, 1);
                }
            }

             // --- Update Letters ---
            for (let i = letters.length - 1; i >= 0; i--) {
                const letter = letters[i];
                letter.x -= SCROLL_SPEED;
                letter.element.style.left = `${letter.x}px`;

                // Collision check ONLY for the NEXT required letter
                if (letter.char === TARGET_WORD[nextLetterIndex] && checkLetterCollision(letter)) {
                    playPlopSound();
                    collectedString += letter.char;
                    uiCollected.textContent = collectedString;

                    letter.element.remove();
                    letters.splice(i, 1);
                    nextLetterIndex++;

                    if (nextLetterIndex < TARGET_WORD.length) {
                        uiNextLetter.textContent = TARGET_WORD[nextLetterIndex];
                    } else {
                        uiNextLetter.textContent = "-";
                    }

                    if (nextLetterIndex === TARGET_WORD.length) {
                        winGame();
                        return;
                    }
                }
                // Remove if off-screen left
                else if (letter.x + letter.width < 0) {
                    letter.element.remove();
                    letters.splice(i, 1);
                }
            }
        }

        function checkLetterCollision(letter) {
            const plTop = clippyY + CLIPPY_HEIGHT;
            const plBottom = clippyY;
            const plLeft = CLIPPY_X_POS;
            const plRight = CLIPPY_X_POS + CLIPPY_WIDTH;

            const elTop = letter.y + letter.height;
            const elBottom = letter.y;
            const elLeft = letter.x;
            const elRight = letter.x + letter.width;

            return (
                plLeft < elRight &&
                plRight > elLeft &&
                plBottom < elTop &&
                plTop > elBottom
            );
        }


        function winGame() {
            if (!gameActive) return;
            console.log("You Win!");
            gameActive = false;
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;

            messageOverlay.innerHTML = `
                <h2>You Collected THRIVING!</h2>
                <p>Great Job!</p>
                <p>Click or press Spacebar to Play Again</p>
            `;
            messageOverlay.style.display = 'flex';
        }


        // --- Game Loop ---
        function gameLoop() {
            if (!gameActive) {
                 animationFrameId = null;
                 return;
            }

            frameCount++;

            applyGravityAndPlatformCheck(); // Handles physics and landing
            updateElements(); // Handles movement and collisions (side hits, letters)

            // Spawn new obstacles based on randomized timer
            if (frameCount >= nextObstacleSpawnFrame) {
                spawnObstacle(); // This function now also sets the *next* spawn time
            }

             // Spawn next required letter periodically, checking spacing
             if (nextLetterIndex < TARGET_WORD.length && frameCount % LETTER_SPAWN_INTERVAL === 0) {
                  let lastElementX = 0;
                  if (obstacles.length > 0) {
                      const lastObs = obstacles[obstacles.length - 1];
                      lastElementX = Math.max(lastElementX, lastObs.x + lastObs.width);
                  }
                  if (letters.length > 0) {
                      const lastLetter = letters[letters.length - 1];
                      lastElementX = Math.max(lastElementX, lastLetter.x + lastLetter.width);
                  }

                  if (lastElementX < GAME_WIDTH - MIN_SPAWN_GAP) {
                       spawnLetter();
                  }
             }

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---
        let initialInteraction = false;
        async function handleInteraction() {
             if (!initialInteraction) {
                 await startAudio();
                 initialInteraction = true;
             }
             if (!gameActive && messageOverlay.style.display !== 'none') {
                  startGame();
             }
             else if (gameActive) {
                  jump();
             }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                handleInteraction();
            }
        });

        messageOverlay.addEventListener('click', () => {
             handleInteraction();
        });

        // --- Initial Setup ---
        messageOverlay.style.display = 'flex';
        clippy.style.bottom = `${GROUND_Y}px`;
        uiNextLetter.textContent = TARGET_WORD[0];
        // Set the very first obstacle spawn time
        setNextObstacleSpawnTime(); // Calculate when the first obstacle should appear
        console.log("Game ready. Press Space or click overlay to start.");


    </script>

</body>
</html>
